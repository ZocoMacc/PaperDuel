<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PaperDuel â€“ Replay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Lightweight Charts standalone build (no bundler needed) -->
  <!-- <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
   -->

  <!-- Added this -->
  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"
        onerror="var s=document.createElement('script');s.src='https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js';document.head.appendChild(s);">
  </script>

  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 16px; color:#eee; background:#121212; }
    .wrap { max-width: 980px; margin: 0 auto; }
    #chart { width: 100%; height: 420px; border: 1px solid #444; border-radius: 8px; overflow: hidden; }
    .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    button { padding:8px 12px; border:1px solid #444; border-radius:6px; background:#2a2a2a; color:#eee; cursor:pointer; }
    button:hover { background:#3a3a3a; }
    .status { margin-top:6px; font-size:14px; color:#444; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Replay</h1>
  <div id="chart"></div>
  <div class="row">
    <button id="play">Play</button>
    <button id="pause">Pause</button>
    <button id="step">Step</button>
    <button id="buy">Buy</button>
    <button id="sell">Sell</button>
    <button id="flat">Flatten</button>
    <button id="end">End / Show Result</button>
  </div>
  <div class="status" id="status">Loadingâ€¦</div>
</div>


<script>
/* ===== PaperDuel â€“ single unified script ===== */

const WINDOW = 120;           // keep last N candles visible
let chart, series;            // chart handles (created on load)
let idx = 0;                  // how many candles rendered
let timer = null;             // play interval id
let battleId = null;
let totalBars = 0;

/* ---- helpers ---- */
function clampWindow() {
  const to = idx, from = Math.max(0, to - WINDOW);
  chart.timeScale().setVisibleLogicalRange({ from, to });
}

function stateToCandle(state) {
  const b = state.bar_data; // {timestamp, open, high, low, close, volume}
  const ts = Math.floor(new Date(b.timestamp.replace(' ', 'T') + 'Z').getTime()/1000);
  return { time: ts, open: b.open, high: b.high, low: b.low, close: b.close };
}

function liveEquity(state) {
  // Multiplier = 50 for ES (you can expand later based on asset)
  const mult = 50;
  const dir  = state?.stats?.position_direction ?? 0;
  const size = state?.stats?.position_size ?? 0;
  const entry= state?.stats?.entry_price ?? 0;
  const last = state?.bar_data?.close ?? 0;
  const unreal = (dir !== 0 && size > 0) ? (last - entry) * dir * size * mult : 0;
  const realized = state?.stats?.equity ?? 0;
  return { unreal, realized, total: realized + unreal, last };
}


async function updateStatus(lastState = null) {
  const st   = lastState || await getState();
  const eq   = liveEquity(st);
  const posD = st?.stats?.position_direction ?? 0;
  const posS = st?.stats?.position_size ?? 0;

  document.getElementById('status').textContent =
    `Bars: ${idx}/${totalBars} | Last: ${eq.last} | Pos: ${posD} x ${posS} | ` +
    `Equity (realized): $${eq.realized.toFixed(2)} | ` +
    `Unrealized: $${eq.unreal.toFixed(2)} | Total: $${eq.total.toFixed(2)}`;
}

async function endBattle() {
  pause();
  // If in a position, queue a close and advance once so it fills
  let st = await getState();
  if (st.stats.position_size > 0 && idx < totalBars - 1) {
    const r = await place("CLOSE");
    if (!r.error) {
      st = await advance();                 // fills close on next bar open
      series.update(stateToCandle(st));
      idx++;
      clampWindow();
    }
  }
  // Final status + equity
  const eq = liveEquity(st);
  alert(
    `Finished!\n` +
    `Status: ${st.status}\n` +
    `Final Equity (realized): $${eq.realized.toFixed(2)}\n` +
    `Unrealized at end: $${eq.unreal.toFixed(2)}\n` +
    `Total: $${eq.total.toFixed(2)}`
  );
}

async function updateStatus(last=null) {
  const st = last || await getState();
  const eq = st?.stats?.equity ?? 0;
  const posDir = st?.stats?.position_direction ?? 0;
  const posSz  = st?.stats?.position_size ?? 0;
  const lastClose = st?.bar_data?.close ?? "â€”";
  document.getElementById('status').textContent =
    `Bars: ${idx}/${totalBars} | Last: ${lastClose} | Pos: ${posDir} x ${posSz} | Equity: $${eq}`;
}

/* ---- API helpers ---- */
async function startBattle(asset="ES") {
  const r = await fetch("/api/battle/start", {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({ asset, user_id:"user_1" })
  });
  const d = await r.json();
  if (!r.ok || !d.battle_id) throw new Error(JSON.stringify(d));
  battleId = d.battle_id; totalBars = d.total_bars;
}
async function getState() {
  const r = await fetch(`/api/battle/${battleId}/state`);
  return await r.json();
}
async function advance() {
  const r = await fetch(`/api/battle/${battleId}/advance`, { method:"POST" });
  return await r.json();
}
async function place(action, payload={}) {
  const r = await fetch(`/api/battle/${battleId}/order`, {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({ action, ...payload })
  });
  return await r.json();
}

/* ---- engine-driven chart flow ---- */
async function seedEngine(n=30) {
  const data = [];
  for (let k=0; k<n; k++) {
    const st = await advance();
    if (st.error) break;
    data.push(stateToCandle(st));
  }
  series.setData(data);
  idx = data.length;
  chart.timeScale().fitContent();
  clampWindow();
  updateStatus();
}
async function appendFromEngine() {
  let st = await advance();
  if (st.error === "battle not found") {
    await startBattle("ES");
    st = await advance();
  }
  if (st.error) { pause(); return; }
  series.update(stateToCandle(st));
  idx++;
  clampWindow();
  updateStatus(st);
  if (st.status && st.status !== "RUNNING") pause();
}
function play(speed=300){ if (!timer) timer = setInterval(appendFromEngine, speed); }
function pause(){ if (timer){ clearInterval(timer); timer = null; } }
async function step(){ await appendFromEngine(); }

/* ---- trading wrappers ---- */
async function buy(){
  const st = await getState();
  if (st.status !== "RUNNING") return alert(`Battle status: ${st.status}`);
  if (st.stats.position_size > 0) return alert("Already in a position. Use Flatten to exit first.");
  if (idx >= totalBars - 1) return alert("No more data to enter.");
  const r = await place("BUY", { size: 1 });   // add sl/tp later
  if (r.error) return alert(r.error);
  alert("BUY queued: it fills on the NEXT bar open. Press Step or Play.");
}

async function sell(){
  const st = await getState();
  if (st.status !== "RUNNING") return alert(`Battle status: ${st.status}`);
  if (st.stats.position_size > 0) return alert("Already in a position. Use Flatten to exit first.");
  if (idx >= totalBars - 1) return alert("No more data to enter.");
  const r = await place("SELL", { size: 1 });
  if (r.error) return alert(r.error);
  alert("SELL queued: it fills on the NEXT bar open. Press Step or Play.");
}

async function closePos(){
  const st = await getState();
  if (st.status !== "RUNNING") return alert(`Battle status: ${st.status}`);
  if (st.stats.position_size <= 0) return alert("No open position to close.");
  if (idx >= totalBars - 1) return alert("No more data to exit.");
  const r = await place("CLOSE");
  if (r.error) return alert(r.error);
  alert("Close queued: it fills on the NEXT bar open. Press Step or Play.");
}


/* ---- boot on page load ---- */
window.addEventListener("load", async () => {
  // 0) verify lib
  if (!window.LightweightCharts || typeof LightweightCharts.createChart !== "function") {
    alert("Chart library failed to load."); return;
  }

  // 1) create chart first so `series` exists before engine runs
  const el = document.getElementById("chart");
  chart = LightweightCharts.createChart(el, {
    width: el.clientWidth, height: 420,
    layout: { background: { color: '#1e1e1e' }, textColor: '#ddd' },
    grid:   { vertLines: { color: '#333' }, horzLines: { color: '#333' } },
    rightPriceScale: { borderVisible: false },
    timeScale: {
      borderVisible: false,
      barSpacing: 6,
      fixLeftEdge: true,
      fixRightEdge: true,
      lockVisibleTimeRangeOnResize: true,
      rightOffset: 0,
      timeVisible: true,      // ðŸ‘ˆ show HH:MM on the x-axis
      secondsVisible: false,  // set to true if you want :ss
    },
  });
  series = chart.addCandlestickSeries();
  window.addEventListener('resize', () => chart.applyOptions({ width: el.clientWidth }));

  // Create legend
  const legend = document.createElement('div');
  legend.style.cssText = 'margin-top:6px;color:#bbb;font:12px system-ui';
  el.parentElement.appendChild(legend);

  const hhmm = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/Chicago',
    hour: '2-digit', minute: '2-digit', hour12: false
  });

  chart.subscribeCrosshairMove(param => {
    const p = param.seriesData.get(series);
    if (!p) { legend.textContent = ''; return; }
    const dt = new Date(p.time * 1000);
    legend.textContent = `${hhmm.format(dt)}  O:${p.open} H:${p.high} L:${p.low} C:${p.close}`;
  });


  // 2) wire buttons now that play/pause/etc exist
  document.getElementById('play').onclick  = ()=>play(300);
  document.getElementById('pause').onclick = pause;
  document.getElementById('step').onclick  = step;
  document.getElementById('buy').onclick   = buy;
  document.getElementById('sell').onclick  = sell;
  document.getElementById('flat').onclick  = closePos;
  document.getElementById('end').onclick = endBattle;

  // 3) start a battle + seed candles from engine
  try {
    await startBattle("ES");
    await seedEngine(30);
  } catch (e) {
    alert("Failed to start battle: " + e);
  }
});
</script>



</body>
</html>
